#' Open a PDB trajectory file for reading
#'
#' @param filename file name of `.pdb` or `.pdb.gz`
#' @param atomids character vector of atom coordinates to return matching characters 13-27 of ATOM records
#' @param frame_max_lines maximum lines to read that must include the first frame
#'
#' @return list structure with data necessary for reads
#'
#' @export
pdb_traj_open <- function(filename, atomids = NULL, frame_max_lines = 10000) {
	
	gzfile_con <- gzfile(filename, "r")
	
	check_lines <- readLines(gzfile_con, frame_max_lines)
	
	seek(gzfile_con, 0)
	
	start_idx <- grep("REMARK    GENERATED BY TRJCONV", check_lines)
	stopifnot(length(start_idx) >= 2)
	
	check_lines <- check_lines[seq_len(diff(start_idx[1:2]))]
	
	atom_idx <- grepl("^ATOM", check_lines)
	
	if (!is.null(atomids)) {
		atom_idx <- atom_idx & substr(check_lines, 13, 27) %in% atomids
	}
	
	list(
		con = gzfile_con,
		nlines = length(check_lines),
		atom_idx = atom_idx,
		atomids = substr(check_lines, 13, 27)[atom_idx]
	)
}

#' Close a PDB trajectory file
#'
#' @param traj_data list structure with data necessary for reads
#'
#' @export
pdb_traj_close <- function(traj_data) {

	try(close(traj_data$con), silent = TRUE)
}

#' Read coordinates from the trajectory
#'
#' @param traj_data list structure with data necessary for reads
#' @param nframes number of frames to read from the trajectory
#' @param check_atomids check whether read atomids equal those expected (taking a performance hit)
#'
#' @return 3D array (xyz, frames, atoms) with atomic coordinates
#'
#' @export
pdb_traj_read <- function(traj_data, nframes = 1000, check_atomids = TRUE) {

	traj_lines <- readLines(traj_data$con, traj_data$nlines*nframes)
	nframes <- floor(length(traj_lines)/traj_data$nlines)
	if (nframes == 0) {
		close(traj_data$con)
		return(NULL)
	}
	traj_lines <- traj_lines[traj_data$atom_idx]
	
	if (check_atomids) {
		atomids <- substr(traj_lines, 13, 27)
		stopifnot(atomids == traj_data$atomids)
	}
	
	x <- as.numeric(substr(traj_lines, 31, 38))
	y <- as.numeric(substr(traj_lines, 39, 46))
	z <- as.numeric(substr(traj_lines, 47, 54))
	
	array(c(x, y, z), dim=c(length(traj_data$atomids), nframes, 3), dimnames=list(traj_data$atomids, NULL, NULL))
}

#' Apply a function to a rolling buffer of trajectory frames
#'
#' @param traj_data list structure with data necessary for reads
#' @param FUN function that takes parameters coord_buffer, nframes, and segment_nums and returns a list with element for each segment
#' @param nframes number of trajectory frames per segment
#' @param nsegments number of segments passed to FUN
#' @param skip number of frames to skip that are included in the first buffer region
#' @param ... additional arguments passed to FUN
#'
#' @return list concatenating returns of all the FUN calls
#'
#' @export
pdb_traj_apply <- function(traj_data, FUN, nframes = 1000, nsegments = 10, skip = 1, ...) {

	active_segments <- nsegments
	segment_size <- nframes
	
	stopifnot(skip <= nframes)

	segment_first2_idx <- seq(1, length.out=2*segment_size)
	segment_last2_idx <- seq(1+active_segments*segment_size, length.out=2*segment_size)
	segment_active_idx <- seq(1+segment_size, length.out=active_segments*segment_size)

	traj_buffer <- array(NA_real_, c((nsegments+2)*segment_size, 3, length(traj_data$atomids)), list(NULL, NULL, traj_data$atomids))

	# load first frame (assumed to be time 0) and first full segment at the end of the buffer
	buffer_read_idx <- utils::tail(segment_last2_idx, skip+segment_size)
	traj_buffer[buffer_read_idx,,] <- aperm(pdb_traj_read(traj_data, skip+segment_size), c(2, 3, 1))

	segment_nums <- seq_len(active_segments)-active_segments
	
	return_list <- list()
	
	repeat {

		# rotate the rolling buffer
		traj_buffer[segment_first2_idx,,] <- traj_buffer[segment_last2_idx,,]
		traj_buffer[-segment_first2_idx,,] <- NA
		segment_nums <- segment_nums + active_segments
	
		# read coordinates into the buffer
		new_coord <- pdb_traj_read(traj_data, segment_size*active_segments)
		if (!is.null(new_coord)) {
			buffer_read_idx <- seq_len(dim(new_coord)[2])+2*segment_size
			traj_buffer[buffer_read_idx,,] <- aperm(new_coord, c(2, 3, 1))
		}
	
		# determine which segments within the active region of the buffer have coordinates
		valid_segments <- apply(matrix(!is.na(traj_buffer[segment_active_idx,1,1]), nrow=segment_size), 2, any)
		if (!any(valid_segments)) {
			break
		}
		stopifnot(sum(valid_segments) == length(which(valid_segments)))
	
		return_list <- c(return_list, FUN(traj_buffer, nframes, segment_nums[valid_segments], ...))
	}
	
	return_list
}

#' Calculate a dipole-dipole interaction tensor autocorrelation function
#'
#' @param coord_buffer 3D array (frames, xyz, atoms) with nframes*(2+length(segment_nums)) frames
#' @param nframes number of trajectory frames per segment
#' @param segment_nums segment numbers for the middle of the buffer
#' @param atom_pair_mat_list list of matrices (pairs, 2) 
#' @param acf_dir directory where <segment_num>.rds files written with calculated ACF
#'
#' @return list with NULL values of length segment_nums
#'
#' @export
pdb_traj_acf <- function(coord_buffer, nframes, segment_nums, atom_pair_mat_list, acf_dir) {

	segment_size <- nframes

	dir.create(acf_dir, showWarnings = FALSE, recursive = TRUE)
	
	print(segment_nums)
	
	acf_files <- file.path(acf_dir, paste0(segment_nums, ".rds"))

	if (all(file.exists(acf_files))) {
		return(NULL)
	}

	acf_lags <- seq_len(nframes)-1
	acf_start_offsets <- ceiling(-acf_lags/2)
	acf_idx <- segment_size+seq_len(segment_size*length(segment_nums))

	# randomize the order in which atom_pair_mat_list is processed to balance worker loads
	future_order <- sample(seq_along(atom_pair_mat_list))
	future_order_rev <- order(future_order)
	
	FUN <- function(i) {

		acf_mat <- matrix(0, nrow=segment_size, ncol=length(segment_nums))
	
		for (j in seq_len(nrow(atom_pair_mat_list[[i]]))) {

			atom1 <- atom_pair_mat_list[[i]][j,1]
			atom2 <- atom_pair_mat_list[[i]][j,2]
			# some wastage here recalculating d_array for the entire buffer
			r_array_buffer <- (coord_buffer[,,atom2]-coord_buffer[,,atom1])*1e-10
			d_array <- r_array_to_d_array(r_array_buffer)
	
			for (k in seq_along(acf_lags)) {
				idx1 <- acf_idx+acf_start_offsets[k]
				idx2 <- idx1+acf_lags[k]
				acf_vals <- rowSums(d_array[idx1,]*d_array[idx2,])
				acf_vals <- colMeans(matrix(acf_vals, nrow=segment_size), na.rm=TRUE)
				acf_mat[k,] <- acf_mat[k,]+acf_vals
			}
		}

		acf_mat/nrow(atom_pair_mat_list[[i]])
	
	}
	
	if (requireNamespace("future.apply", quietly = TRUE)) {
		acf_list <- future.apply::future_lapply(seq_along(atom_pair_mat_list)[future_order], FUN)[future_order_rev]
	} else {
		acf_list <- lapply(seq_along(atom_pair_mat_list)[future_order], FUN)[future_order_rev]
	}

	acf_array <- simplify2array(acf_list)

	for (i in seq_len(dim(acf_array)[2])) {
		saveRDS(acf_array[,i,], acf_files[i])
	}
	
	rep(list(NULL), length(segment_nums))
}
